[![Build Status](https://travis-ci.org/rwstauner/ynetd.svg?branch=master)](https://travis-ci.org/rwstauner/ynetd)

# ynetd

A tiny super server written in go.

    ynetd -proxy ":8080 localhost:8081" cmd arg...

- Listen on the specified address for connections.
- When one is received, launch the specified program (with arguments).
- Wait for the specified port to become ready.
- Forward this connection (and all future traffic) to the new service.

If you have a service that might not be used
you can make it available while only consuming a tiny amount of RAM
when it isn't needed.

The impetus for this was a docker-compose project with a handful
of micro services.  Each service consumes several hundred megabytes
of RAM, while some of them might never be used during any given
`docker-compose up` session.

Rather than fiddling with which services to launch or exclude and how to make
them available when needed, just put `ynetd` in front of them.
RAM usage for each container is now only 500K but the services will vivify
automatically if a request to them is made.

## Installation

Download the zip file for your OS from the [releases](https://github.com/rwstauner/ynetd/releases) page
or use something like this:

    YNETD_VERSION=v0.10
    wget -qO /tmp/ynetd.zip https://github.com/rwstauner/ynetd/releases/download/$YNETD_VERSION/ynetd-linux-amd64.zip \
      && unzip -d /usr/local/bin/ /tmp/ynetd.zip \
      && rm -f /tmp/ynetd.zip


## Configuration

One service can be configured on the command line:

    -proxy            # Address pairs to listen on/proxy to ("from:port to:port from2 to2")
    -proxy-sep        # Alternate character to separate proxy addresses
    -stop-after       # Duration after last connection to signal command to stop
    -stop-signal      # Signal to send to command (default is TERM)
    -timeout          # Duration to wait before aborting connection
    -wait-after-start # Duration to wait after starting command before forwarding connections
    args...           # Command to run

Alternatively (or additionally) multiple services
can be configured by specifying the path to a YAML configuration file:

    -config /path/to/ynetd.conf

Which should look something like:

    ---
    services:
      -
        proxy:
          ":5000": "localhost:5001"
          ":6543": "localhost:7654"
        command:
          - run
          - some
          - server
        stop_after: 10m
        stop_signal: TERM
        timeout: 10s
        wait_after_start: 2s

Everything is optional (except for "proxy").

Without a command to run, ynetd can be used as a simple port forwarder:

    ynetd -proxy "localhost:5001 remote.host:8080"

Addresses can be specified as "host:port", ":port" (all addresses)
or as "interface:name:port" ("interface:eth0:5001") to listen on
(all addresses of) the named interface.

This can be useful if you don't know the ip address up front
but want to forward from public interface to loopback
to avoid having to use additional port numbers:

    -proxy "interface:eth0:5000 localhost:5000"

## Why?

- To reduce resource utilization for services until they are needed.
- To regain resources when they are no longer needed.
- To simplify container configuration.
- To learn a little go.

## Why the name?

I wanted something like `xinted` but something that would launch
another (long running) server and just forward connections.

- "y" comes after "x"
- Maybe `[tin]ynetd`
- Stop asking ":why: are you eating all my RAM?"
- y not?
